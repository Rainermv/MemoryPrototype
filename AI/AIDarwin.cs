//------------------------------------------------------------------------------
// <auto-generated>
//     O código foi gerado por uma ferramenta.
//     Versão de Tempo de Execução:4.0.30319.18444
//
//     As alterações ao arquivo poderão causar comportamento incorreto e serão perdidas se
//     o código for gerado novamente.
// </auto-generated>
//------------------------------------------------------------------------------
//using System;
using System.Collections.Generic;
using UnityEngine;

namespace AIMemory
{
	public class AIDarwin
	{
		// SINGLETON
		private AIDarwin ()
		{
		}
		
		private static AIDarwin instance;
		
		public static AIDarwin GetInstance(){
		
			if (instance == null)
				instance = new AIDarwin();
				
			return instance;
		
		}
		
		// ---------------------------------------
		private static int SPECIMENTS = 10;
		private static float TARGET_RATIO = 0.75f;
		private static int CULLING = 2;
		
		private static float ANOMALY_CHANCE = 0.2f;
		
		public float TRatio{
			get{return TARGET_RATIO;}
		}
		
		private int generation = 0;
		
		private List<AIPlayer> player_breed;
		private List<AIPlayer> next_gen = new List<AIPlayer>();
		
		private int next_player = 0;
		
		public AIPlayer NextPlayer(){
		
			if (player_breed == null){
				player_breed = new List<AIPlayer>();
				
				Generate ();
				
				generation++;
			}
			
			else if (next_player >= player_breed.Count){
				next_player = 0;
				
				AIDebug.GenLog("|||||||||||||||||||||||||||||||||||||");
				AIDebug.GenLog("END OF GENERATION " + generation);
				
				generation++;
				
				ReGenerate ();
				
				
				AIDebug.Warning("GENERATION RESULTS");
				
				foreach (AIPlayer p in player_breed){
					p.DebugChromossome();
				}
				
				
			}
			
			return player_breed[next_player++];
		}
		
		public AIPlayer GetPlayer(int ind){
			
			if (ind < player_breed.Count)
				return player_breed[ind];
				
			AIDebug.Warning("AIDarwing - breed index out of range");
			return null;
		}
		
		// Create the first generation with random values
		private void Generate(){
			
			for (int i = 0; i < SPECIMENTS; i++){
				player_breed.Add (new AIPlayer("S"+"-"+generation+i,true));
			}
			
			
		}
		
		// create the subsequent generations
		private void ReGenerate (){
		
			next_gen.Clear();
			
			Sort (ref player_breed);
			
			CullTheWeak();
			
			// create a temporary list for the players that will breed
			List<AIPlayer> breeders = new List<AIPlayer>();
			breeders.AddRange(player_breed);
			
			// breed all the players
			int i = 0;
			foreach (AIPlayer speciment in player_breed){
				Breed(ref breeders, speciment, i++);
			}
			
			// maintain the best players
			DoSelection ();
			
		}
		
		// the chosen speciment breeds with another random speciment
		private void Breed(ref List<AIPlayer> breeders, AIPlayer speciment, int index){
			
			// remove the speciment from the list, 
			// so it will not breed with itself
			
			if (breeders.Count > 1)
				breeders.Remove(speciment);
			
			AIChromossome c1 = speciment.Chromossome;
			AIChromossome c2 = breeders[Random.Range(0,breeders.Count)].Chromossome;
			AIChromossome c_child = new AIChromossome(c1,c2,ANOMALY_CHANCE);
			
			next_gen.Add (new AIPlayer("S"+"-"+generation+index,c_child));
			
			
		
		}
		
		// maintain the best speciments to the next generation
		private void DoSelection(){
		
			//Debug.Log ("DO SELECTION - player breed count is " + player_breed.Count);
			//Debug.Log ("DO SELECTION - next gen count is " + player_breed.Count);
			
			for (int i = 0; i < CULLING; i++){
				if (i >= player_breed.Count) 
					break;
					
				next_gen.Add(player_breed[i]);
			}
			
			// kill the remaining players
			player_breed.Clear ();
			player_breed.AddRange(next_gen);
			next_gen.Clear();
		
		}
		
		// destroy the two worst speciments before it breeds
		private void CullTheWeak(){
			//Debug.LogWarning(player_breed.Count);
			player_breed.RemoveRange(player_breed.Count - CULLING, CULLING);
			//Debug.LogWarning(player_breed.Count);

		}
		
		// sort a player list with the better score first
		private void Sort(ref List<AIPlayer> player_list){
		
			for (int i = 0; i < player_list.Count; i++){
				
				AIPlayer best = player_list[i];
				int b = i;
				
				for (int j = 0; j < player_list.Count; j++){
				
					AIPlayer contestant = player_list[j];
					if (contestant.RatioScore > best.RatioScore){
						best = contestant;
						b = j;
					}
				}	
				
				Swap(ref player_list,i,b);	
				
			}
		
		}
		
		// swap two players from a list
		private void Swap(ref List<AIPlayer> player_list, int a, int b){
			
			AIPlayer temp = player_list[a];
			player_list[a] = player_list[b];
			player_list[b] = temp;
		}
	}
}

